using System;
using cAlgo.API;
using cAlgo.API.Internals;

namespace cAlgo.Robots
{
    [Robot(TimeZone = TimeZones.CentralEuropeStandardTime, AccessRights = AccessRights.None)]
    public class EURUSD_MorningBreakout : Robot
    {
        [Parameter("Risk %", DefaultValue = 1.0)]
        public double RiskPercentage { get; set; }

        [Parameter("Reward Ratio", DefaultValue = 2.0)]
        public double RewardRatio { get; set; }

        private double _refHigh;
        private double _refLow;
        private bool _isWaiting;
        private DateTime _lastTradeDate;

        protected override void OnTick()
        {
            var now = Server.Time;

            // Lock the 07:50 - 08:00 candle range at 08:00
            if (now.Hour == 8 && now.Minute == 0 && _lastTradeDate.Date != now.Date)
            {
                var candle = Bars.Last(1);
                _refHigh = candle.High;
                _refLow = candle.Low;
                _isWaiting = true;
                _lastTradeDate = now.Date;
            }

            if (!_isWaiting) return;

            if (Symbol.Ask > _refHigh)
                OpenPosition(TradeType.Buy);
            else if (Symbol.Bid < _refLow)
                OpenPosition(TradeType.Sell);
        }

        private void OpenPosition(TradeType type)
        {
            _isWaiting = false;

            // SL is the low (for Buy) or high (for Sell) of the previous candle
            double stopLossPrice = (type == TradeType.Buy) ? _refLow : _refHigh;
            double entryPrice = (type == TradeType.Buy) ? Symbol.Ask : Symbol.Bid;
            double distance = Math.Abs(entryPrice - stopLossPrice);

            if (distance <= 0) return;

            // 1% of current balance (e.g., 820 EUR)
            double riskInCurrency = Account.Balance * (RiskPercentage / 100);

            // Volume = Risk / (Distance * ValuePerPoint)
            // For EURUSD on a EUR account, this is very stable.
            double rawVolume = riskInCurrency / (distance * Symbol.LotSize / Symbol.Ask);
            double volumeUnits = Symbol.NormalizeVolumeInUnits(rawVolume * Symbol.LotSize);

            double slPips = distance / Symbol.PipSize;
            double tpPips = slPips * RewardRatio;

            ExecuteMarketOrder(type, SymbolName, volumeUnits, "Breakout", slPips, tpPips);
        }
    }
}
