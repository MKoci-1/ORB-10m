using System;
using cAlgo.API;
using cAlgo.API.Internals;

namespace cAlgo.Robots
{
    public enum DirectionMode
    {
        Both,
        LongOnly,
        ShortOnly
    }

    [Robot(TimeZone = TimeZones.CentralEuropeStandardTime, AccessRights = AccessRights.None)]
    public class EURUSD_MorningBreakout_Final : Robot
    {
        [Parameter("Trade Direction", DefaultValue = DirectionMode.Both)]
        public DirectionMode Mode { get; set; }

        [Parameter("Risk %", DefaultValue = 1.0)]
        public double RiskPercentage { get; set; }

        [Parameter("Reward Ratio", DefaultValue = 2.0)]
        public double RewardRatio { get; set; }

        private double _refHigh, _refLow;
        private bool _isWaiting;
        private DateTime _lastTradeDate;

        protected override void OnTick()
        {
            var now = Server.Time;

            // Triggered at 08:00 Czech local time (handles Summer/Winter automatically)
            if (now.Hour == 8 && now.Minute == 0 && _lastTradeDate.Date != now.Date)
            {
                var candle = Bars.Last(1); // 07:50 - 08:00 candle
                _refHigh = candle.High;
                _refLow = candle.Low;
                _isWaiting = true;
                _lastTradeDate = now.Date;
            }

            if (!_isWaiting) return;

            // Long Entry
            if (Symbol.Ask > _refHigh && (Mode == DirectionMode.Both || Mode == DirectionMode.LongOnly))
            {
                ExecuteCleanTrade(TradeType.Buy, _refLow);
            }
            // Short Entry
            else if (Symbol.Bid < _refLow && (Mode == DirectionMode.Both || Mode == DirectionMode.ShortOnly))
            {
                ExecuteCleanTrade(TradeType.Sell, _refHigh);
            }
        }

        private void ExecuteCleanTrade(TradeType type, double ghostStopLevel)
        {
            _isWaiting = false;

            double entryPrice = (type == TradeType.Buy) ? Symbol.Ask : Symbol.Bid;
            double distance = Math.Abs(entryPrice - ghostStopLevel);

            if (distance <= 0) return;

            // 1% Risk Calculation for EUR account
            double riskInCurrency = Account.Balance * (RiskPercentage / 100);
            double rawVolume = riskInCurrency / (distance / entryPrice);
            double volumeUnits = Symbol.NormalizeVolumeInUnits(rawVolume);

            double tpPips = (distance / Symbol.PipSize) * RewardRatio;

            // Placing order with NO Stop Loss on the broker's book
            ExecuteMarketOrder(type, SymbolName, volumeUnits, "Breakout", null, tpPips);
            
            Print("{0} breakout executed. Volume: {1} units.", type, volumeUnits);
        }
    }
}
